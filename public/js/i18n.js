const LANG = {
  en: {
    title: 'Claude Token Tracker',
    today: 'Today',
    days7: '7 Days',
    days30: '30 Days',
    allTime: 'All Time',
    live: 'Live',
    rebuildCache: 'Rebuild Cache',
    rebuilding: 'Rebuilding...',
    // Tabs
    overview: 'Overview',
    sessions: 'Sessions',
    projects: 'Projects',
    tools: 'Tools',
    models: 'Models',
    insights: 'Insights',
    info: 'Info',
    // KPI
    totalTokens: 'Total Tokens',
    estimatedCost: 'Estimated Cost',
    sessionsLabel: 'Sessions',
    messagesLabel: 'Messages',
    costSubLabel: 'API-equivalent estimate',
    uniqueSessions: 'Unique sessions',
    assistantResponses: 'Assistant responses',
    kpiTokensSub: (i, o, c) => `In: ${i} | Out: ${o} | Cache: ${c}`,
    kpiTokensSubNoCache: (i, o) => `In: ${i} | Out: ${o}`,
    cacheOn: 'Cache: On',
    cacheOff: 'Cache: Off',
    // Info tab
    infoTitle: 'How Token Tracking Works',
    infoInputTitle: 'Input Tokens',
    infoInputDesc: 'Tokens sent to the model in your prompt — your question, code context, system instructions, and conversation history. These are the tokens Claude reads to understand your request.',
    infoOutputTitle: 'Output Tokens',
    infoOutputDesc: 'Tokens generated by Claude in its response — code, explanations, tool calls. These are typically the most expensive tokens per unit.',
    infoCacheReadTitle: 'Cache Read Tokens',
    infoCacheReadDesc: 'Input tokens served from Anthropic\'s prompt cache instead of being reprocessed. When parts of your prompt (like system instructions or long context) repeat across requests, they can be cached. Cache reads are significantly cheaper than regular input tokens (~90% cheaper).',
    infoCacheCreateTitle: 'Cache Create Tokens',
    infoCacheCreateDesc: 'Tokens written to the prompt cache for the first time. This is a one-time cost per unique prompt prefix. Subsequent requests that share this prefix will benefit from cache read pricing. Cache create costs are similar to regular input pricing.',
    infoCostTitle: 'Cost Estimation',
    infoCostDesc: 'Costs shown are API-equivalent estimates based on official Anthropic pricing per model. Claude Code (Max plan) is billed as a flat subscription, not per token. These estimates show what your usage would cost at API rates — useful for understanding relative usage patterns and comparing efficiency.',
    infoDataSourceTitle: 'Data Source',
    infoDataSourceDesc: 'All data is parsed from Claude Code\'s JSONL session files stored locally at ~/.claude/projects/. No data is sent to any external service. The tracker reads these files, extracts token counts per message, and stores them in a local SQLite database for fast aggregation.',
    infoToggleTitle: 'Cache Toggle',
    infoToggleDesc: 'By default, cached tokens are hidden from statistics because they represent infrastructure overhead rather than actual content processed. Use the "Cache" toggle in the header to include them. When cache is included, you see the full picture; when excluded, you see only the tokens that directly contribute to your interactions.',
    infoPricingTitle: 'Model Pricing (per 1M tokens)',
    // Charts
    dailyTokenUsage: 'Daily Token Usage',
    dailyCostTrend: 'Daily Cost Trend',
    modelDistribution: 'Model Distribution',
    activityByHour: 'Activity by Hour',
    tokensByProject: 'Tokens by Project',
    toolUsage: 'Tool Usage',
    modelUsageOverTime: 'Model Usage Over Time',
    // Insights
    costBreakdown: 'Cost Breakdown',
    cumulativeCost: 'Cumulative Cost',
    weekdayActivity: 'Weekday Activity',
    cacheEfficiency: 'Cache Efficiency',
    stopReasons: 'Stop Reasons',
    sessionEfficiency: 'Session Efficiency',
    // Table headers
    date: 'Date',
    project: 'Project',
    model: 'Model',
    duration: 'Duration',
    messages: 'Messages',
    toolCalls: 'Tools',
    tokens: 'Tokens',
    cost: 'Cost',
    totalTokensH: 'Total Tokens',
    input: 'Input',
    output: 'Output',
    cacheRead: 'Cache Read',
    cacheCreate: 'Cache Create',
    calls: 'Calls',
    pctTotal: '% of Total',
    tool: 'Tool',
    allProjects: 'All Projects',
    // Chart legends
    inputLabel: 'Input',
    outputLabel: 'Output',
    cacheReadLabel: 'Cache Read',
    cacheCreateLabel: 'Cache Create',
    apiEquivCost: 'API-equivalent Cost',
    // Stats-cache
    officialStats: 'Claude Stats (All Time)',
    parsedFromFiles: 'from session files on disk',
    totalMsgsOfficial: 'official total',
    // Data source
    dataSource: 'Source: JSONL session files',
    // Tooltips
    tooltipTotalTokens: 'Sum of input, output, cache-read, and cache-create tokens for the selected period',
    tooltipEstimatedCost: 'Cost estimate based on official API pricing per model — not actual billing',
    tooltipSessions: 'Number of unique Claude Code sessions (each CLI invocation = 1 session)',
    tooltipMessages: 'Number of assistant responses (API round-trips)',
    tooltipDailyTokens: 'Stacked bar chart showing token consumption by type per day',
    tooltipDailyCost: 'API-equivalent cost trend over time',
    tooltipModelDist: 'Token share per Claude model (Opus, Sonnet, Haiku)',
    tooltipHourly: 'When are you most active? Messages grouped by hour of day',
    tooltipCostBreakdown: 'Cost split by token type: input, output, cache-read, cache-create',
    tooltipCumulativeCost: 'Running total of estimated costs over time',
    tooltipWeekday: 'Messages and costs grouped by day of week',
    tooltipCacheEfficiency: 'Daily cache hit rate: cache-read / (input + cache-read + cache-create)',
    tooltipStopReasons: 'Why did the model stop? end_turn = natural, tool_use = called a tool',
    tooltipSessionEfficiency: 'Tokens per message vs. cost per message — lower-left is most efficient',
  },
  de: {
    title: 'Claude Token Tracker',
    today: 'Heute',
    days7: '7 Tage',
    days30: '30 Tage',
    allTime: 'Gesamt',
    live: 'Live',
    rebuildCache: 'Cache neu aufbauen',
    rebuilding: 'Wird aufgebaut...',
    // Tabs
    overview: 'Übersicht',
    sessions: 'Sitzungen',
    projects: 'Projekte',
    tools: 'Tools',
    models: 'Modelle',
    insights: 'Insights',
    info: 'Info',
    // KPI
    totalTokens: 'Tokens gesamt',
    estimatedCost: 'Geschätzte Kosten',
    sessionsLabel: 'Sitzungen',
    messagesLabel: 'Nachrichten',
    costSubLabel: 'API-äquivalente Schätzung',
    uniqueSessions: 'Einzigartige Sitzungen',
    assistantResponses: 'Assistenten-Antworten',
    kpiTokensSub: (i, o, c) => `In: ${i} | Out: ${o} | Cache: ${c}`,
    kpiTokensSubNoCache: (i, o) => `In: ${i} | Out: ${o}`,
    cacheOn: 'Cache: An',
    cacheOff: 'Cache: Aus',
    // Info tab
    infoTitle: 'So funktioniert das Token-Tracking',
    infoInputTitle: 'Input Tokens',
    infoInputDesc: 'Tokens, die an das Modell gesendet werden — deine Frage, Code-Kontext, Systemanweisungen und Gesprächsverlauf. Diese Tokens liest Claude, um deine Anfrage zu verstehen.',
    infoOutputTitle: 'Output Tokens',
    infoOutputDesc: 'Tokens, die Claude in seiner Antwort generiert — Code, Erklärungen, Tool-Aufrufe. Diese sind pro Einheit in der Regel die teuersten Tokens.',
    infoCacheReadTitle: 'Cache Read Tokens',
    infoCacheReadDesc: 'Input-Tokens, die aus Anthropics Prompt-Cache gelesen werden, anstatt neu verarbeitet zu werden. Wenn Teile deines Prompts (wie Systemanweisungen oder langer Kontext) sich über Anfragen wiederholen, können sie gecacht werden. Cache-Reads sind deutlich günstiger als reguläre Input-Tokens (~90% günstiger).',
    infoCacheCreateTitle: 'Cache Create Tokens',
    infoCacheCreateDesc: 'Tokens, die erstmalig in den Prompt-Cache geschrieben werden. Dies ist ein einmaliger Aufwand pro eindeutigem Prompt-Präfix. Folgende Anfragen mit gleichem Präfix profitieren dann vom Cache-Read-Preis. Cache-Create-Kosten sind ähnlich wie reguläre Input-Kosten.',
    infoCostTitle: 'Kostenschätzung',
    infoCostDesc: 'Die angezeigten Kosten sind API-äquivalente Schätzungen basierend auf offiziellen Anthropic-Preisen pro Modell. Claude Code (Max-Plan) wird als Flatrate-Abonnement abgerechnet, nicht pro Token. Diese Schätzungen zeigen, was deine Nutzung zu API-Preisen kosten würde — nützlich zum Verständnis relativer Nutzungsmuster.',
    infoDataSourceTitle: 'Datenquelle',
    infoDataSourceDesc: 'Alle Daten werden aus den lokalen JSONL-Sitzungsdateien von Claude Code unter ~/.claude/projects/ gelesen. Es werden keine Daten an externe Dienste gesendet. Der Tracker liest diese Dateien, extrahiert Token-Zähler pro Nachricht und speichert sie in einer lokalen SQLite-Datenbank.',
    infoToggleTitle: 'Cache-Umschalter',
    infoToggleDesc: 'Standardmäßig werden gecachte Tokens in den Statistiken ausgeblendet, da sie Infrastruktur-Overhead darstellen und nicht tatsächlich verarbeiteten Inhalt. Nutze den "Cache"-Schalter im Header, um sie einzubeziehen. Mit Cache siehst du das vollständige Bild; ohne Cache nur die Tokens, die direkt zu deinen Interaktionen beitragen.',
    infoPricingTitle: 'Modell-Preise (pro 1M Tokens)',
    // Charts
    dailyTokenUsage: 'Täglicher Token-Verbrauch',
    dailyCostTrend: 'Täglicher Kosten-Trend',
    modelDistribution: 'Modell-Verteilung',
    activityByHour: 'Aktivität nach Uhrzeit',
    tokensByProject: 'Tokens nach Projekt',
    toolUsage: 'Tool-Nutzung',
    modelUsageOverTime: 'Modell-Nutzung im Zeitverlauf',
    // Insights
    costBreakdown: 'Kostenaufschlüsselung',
    cumulativeCost: 'Kumulative Kosten',
    weekdayActivity: 'Wochentags-Aktivität',
    cacheEfficiency: 'Cache-Effizienz',
    stopReasons: 'Stop Reasons',
    sessionEfficiency: 'Session-Effizienz',
    // Table headers
    date: 'Datum',
    project: 'Projekt',
    model: 'Modell',
    duration: 'Dauer',
    messages: 'Nachrichten',
    toolCalls: 'Tools',
    tokens: 'Tokens',
    cost: 'Kosten',
    totalTokensH: 'Tokens gesamt',
    input: 'Input',
    output: 'Output',
    cacheRead: 'Cache Read',
    cacheCreate: 'Cache Create',
    calls: 'Aufrufe',
    pctTotal: '% gesamt',
    tool: 'Tool',
    allProjects: 'Alle Projekte',
    // Chart legends
    inputLabel: 'Input',
    outputLabel: 'Output',
    cacheReadLabel: 'Cache Read',
    cacheCreateLabel: 'Cache Create',
    apiEquivCost: 'API-äquivalente Kosten',
    // Stats-cache
    officialStats: 'Claude Stats (gesamt)',
    parsedFromFiles: 'aus Sitzungsdateien auf Disk',
    totalMsgsOfficial: 'offizielle Gesamtzahl',
    // Data source
    dataSource: 'Quelle: JSONL-Sitzungsdateien',
    // Tooltips
    tooltipTotalTokens: 'Summe aus Input-, Output-, Cache-Read- und Cache-Create-Tokens im gewählten Zeitraum',
    tooltipEstimatedCost: 'Kostenschätzung basierend auf offiziellen API-Preisen pro Modell — keine echte Abrechnung',
    tooltipSessions: 'Anzahl einzigartiger Claude-Code-Sitzungen (jeder CLI-Aufruf = 1 Sitzung)',
    tooltipMessages: 'Anzahl der Assistenten-Antworten (API-Roundtrips)',
    tooltipDailyTokens: 'Gestapeltes Balkendiagramm: Token-Verbrauch nach Typ pro Tag',
    tooltipDailyCost: 'API-äquivalenter Kostentrend über die Zeit',
    tooltipModelDist: 'Token-Anteil pro Claude-Modell (Opus, Sonnet, Haiku)',
    tooltipHourly: 'Wann bist du am aktivsten? Nachrichten gruppiert nach Tageszeit',
    tooltipCostBreakdown: 'Kosten aufgeteilt nach Token-Typ: Input, Output, Cache-Read, Cache-Create',
    tooltipCumulativeCost: 'Laufende Gesamtkosten über die Zeit',
    tooltipWeekday: 'Nachrichten und Kosten gruppiert nach Wochentag',
    tooltipCacheEfficiency: 'Tägliche Cache-Hit-Rate: Cache-Read / (Input + Cache-Read + Cache-Create)',
    tooltipStopReasons: 'Warum hat das Modell gestoppt? end_turn = natürlich, tool_use = Tool aufgerufen',
    tooltipSessionEfficiency: 'Tokens pro Nachricht vs. Kosten pro Nachricht — unten links ist am effizientesten',
  }
};

let currentLang = localStorage.getItem('lang') || 'de';

function t(key) {
  return LANG[currentLang][key] || LANG.en[key] || key;
}

function setLang(lang) {
  currentLang = lang;
  localStorage.setItem('lang', lang);
  applyTranslations();
}

function applyTranslations() {
  // Update all elements with data-i18n attribute
  document.querySelectorAll('[data-i18n]').forEach(el => {
    el.textContent = t(el.dataset.i18n);
  });
  // Update lang buttons
  document.querySelectorAll('.lang-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.lang === currentLang);
  });
}
